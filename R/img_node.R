#' @title Obtains the filename for images in the Markdown file.
#'
#' @description Function is used on each line to find any image and to return the name if there is.
#'
#' @param codeline The line of code on which the function is scanning.
#' @param img_pattern The pattern in which the function is using to search for the images
#'
#' @return The filename of the images
get_img_fn <- function(codeline, img_pattern=get_martmi_cfg('img_node') ){
  ##### added require to call up the 'stringr' package in order to use str_match
  require(stringr)
  ##### some value renaming
  img_fn <- str_match(codeline, img_pattern)[,2]
  return(img_fn)
}

#' @title Takes the image name and makes it display in the Mindmap file
#'
#' @description The function uses the name of the image to find where it is located and to display it in a seperate node in the Mindmap file.
#'
#' @param codeline The line of Markdown code in which the function is scanning for any images based on the regex pattern.
#' @param img_pattern The regex pattern that is used to locate the images in the Markdown file.
#'
#' @return XML code of the image that will allow it to be displayed in the Mindmap. If no image exists, then the function will return nothing.
img_node <- function(codeline, img_pattern=get_martmi_cfg("img_node")){
  rv <- ""
  #runs function 'get_img_fn' to find where there is an image in the function
  img_fn <- get_img_fn(codeline, img_pattern)

  # pre_img_code and post_img_code contains the beginning and end of the XML code that encapsulates the image file. The beginning and ending for the images are very similar to the beginning and ending of the code, with the exception of the images using <p> and </p> instead of <pre> and </pre>. The width and height if the image are set to a hard 90 width and 120 height in pixels
  pre_img_code <- '<richcontent TYPE="NODE"><html>
  <head>
  </head>
  <body>
  <p><img width="100%" height="100%" src="'
  post_img_code <- '"/>
  </p>
  </body>
  </html>
  </richcontent>
  '
  #asks whether the image exists, and executes alternate code if the img does exist
  if(!is.na(img_fn)){
    # the rmd is supposed in the src folder where the project working folder is ".." relative to the rmd location
    ### value contains path to the file that is the input. Chooses not to display any errors if no results can be determined
    abs_fn <- normalizePath(file.path(dirname(.RMD_FN.), "..", img_fn), mustWork = F)
    #displays the file path generated, seperating it into new lines instead of one long line
    # cat(abs_fn, "\n")
    ###checks to see if the path generated by abs.fn does exist, as mustWork=F and the program was made to continue, even if the file did not exist. Hence the need to check it.
    if(file.exists(abs_fn)){
      # start to return something
      # create a new png file under the .image folder using sips

      ### creates a new file within the .image folder, and ignores warnings that come with the creation
      .img_folder = file.path(dirname(abs_fn), ".images")
      dir.create(.img_folder, showWarnings = FALSE)

      ### New value where the ending part of the abs_fn is replaced by png
      .img_png <- sub("\\.(.+)$", ".png", basename(abs_fn))
      ### New value where the file path is obtained for .img_folder and .img_png
      ## Why do you put both .img_folder and .img_png in it?
      new_abs_fn <- file.path(.img_folder, .img_png)
      ### Value is a command that formats the abs_fn and new_abs_fn into a png
      ## Why do you use both abs_fn and what does -s, -Z, and --out mean?
      sips_cmd <- sprintf("sips -s format png -Z 200  %s --out %s", abs_fn, new_abs_fn)
      ### assuming that this opens iTerm to execute the command in order to implement the new png file into the computer, and to put the result as a R character vector
      cmd_rv <- system(sips_cmd, intern = T)

      rv <- c(startnode(paste0('!!!',''),  endnode=F), pre_img_code, new_abs_fn, post_img_code, endnode())


    }
  }
  ### Entire function was a huge if function, returning a value if there is an image within the .rmd file but returning nothing if there is no file.
  return(rv) # empty return otherwise
}
